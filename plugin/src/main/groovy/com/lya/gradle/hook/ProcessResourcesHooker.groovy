package com.lya.gradle.hook

import com.android.build.gradle.AndroidConfig
import com.android.build.gradle.AppExtension
import com.android.build.gradle.api.ApkVariant
import com.android.build.gradle.tasks.ProcessAndroidResources
import com.android.sdklib.BuildToolInfo
import com.google.common.collect.ListMultimap
import com.google.common.io.Files
import com.lya.gradle.aapt.Aapt
import com.lya.gradle.collector.ResourceCollector
import com.lya.gradle.collector.res.ResourceEntry
import com.lya.gradle.collector.res.StyleableEntry
import com.lya.gradle.utils.ZipUtil
import org.gradle.api.Project
/**
 * Filter the host resources out of the plugin apk.
 * Modify the .arsc file to delete host element,
 * rearrange plugin element, hold the new resource IDs
 */
class ProcessResourcesHooker extends GradleTaskHooker<ProcessAndroidResources> {

    /**
     * Collector to gather the sources and styleables
     */
    ResourceCollector resourceCollector
    /**
     * Android config information specified in build.gradle
     */
    AndroidConfig androidConfig

    ProcessResourcesHooker(Project project, ApkVariant apkVariant) {
        super(project, apkVariant)
        androidConfig = project.extensions.findByType(AppExtension)
    }

    @Override
    String getTaskName() {
        return "process${apkVariant.name.capitalize()}Resources"
    }

    @Override
    void beforeTaskExecute(ProcessAndroidResources aaptTask) {
        super.beforeTaskExecute(aaptTask)
    }

    /**
     * Since we need to remove the host resources and modify the resource ID,
     * we will reedit the AP_ file and repackage it after the task execute
     *
     * @param par Gradle task of process android resources
     */
    @Override
    void afterTaskExecute(ProcessAndroidResources par) {
        super.afterTaskExecute(par)
        def apFile = par.packageOutputFile // resources-debug.ap_
        def resourcesDir = new File(apFile.parentFile, Files.getNameWithoutExtension(apFile.name)) // resources-debug
        if (showLog) {
            println 'ProcessAndroidResources packageOutputFile: ' + apFile.name + " " + resourcesDir.getName()
        }
        resourcesDir.deleteDir()

        project.copy {
            from project.zipTree(apFile)
            into resourcesDir

            include 'AndroidManifest.xml'
            include 'resources.arsc'
            include 'res/**/*'
        }

        resourceCollector = new ResourceCollector(project, par)
        resourceCollector.collect()

        def retainedTypes = convertResourcesForAapt(resourceCollector.pluginResources)
        def retainedStylealbes = convertStyleablesForAapt(resourceCollector.pluginStyleables)
        def resIdMap = resourceCollector.resIdMap
//
        def rSymbolFile = new File(par.textSymbolOutputDir, 'R.txt')
        def libRefTable = ["${extension.packageId}": par.packageForR]
        if (showLog) {
            println 'libRefTable: ' + libRefTable
        }
        def filteredResources = [] as HashSet<String>
        def updatedResources = [] as HashSet<String>

        def aapt = new Aapt(resourcesDir, rSymbolFile, androidConfig.buildToolsRevision)

        //Delete host resources, must do it before filterPackage
        aapt.filterResources(retainedTypes, filteredResources)
        //Modify the arsc file, and replace ids of related xml files
        aapt.filterPackage(retainedTypes, retainedStylealbes, extension.packageId, resIdMap, libRefTable, updatedResources)

        /*
         * Delete filtered entries and then add updated resources into resources-${variant.name}.ap_
         */
        ZipUtil.with(apFile).deleteAll(filteredResources + updatedResources)

        project.exec {
            executable par.buildTools.getPath(BuildToolInfo.PathId.AAPT)
            workingDir resourcesDir
            args 'add', apFile.path
            args updatedResources
            standardOutput = new ByteArrayOutputStream()
        }

        updateRJava(aapt, par.sourceOutputDir)
    }

    /**
     * Because the resource ID has changed, we need to regenerate the R.java file,
     * include the all resources R, plugin resources R, and R files of retained aars
     *
     * @param aapt Class to expand aapt function
     * @param sourceOutputDir Directory of R.java files generated by aapt
     *
     */
    def updateRJava(Aapt aapt, File sourceOutputDir) {

        sourceOutputDir.deleteDir()

        def rSourceFile = new File(sourceOutputDir, "${extension.packagePath}${File.separator}R.java")
        aapt.generateRJava(rSourceFile, apkVariant.applicationId, resourceCollector.allResources, resourceCollector.allStyleables)

        def splitRSourceFile = new File(sourceOutputDir.parentFile, "va${File.separator}${extension.packagePath}${File.separator}R.java")
        aapt.generateRJava(splitRSourceFile, apkVariant.applicationId, resourceCollector.pluginResources, resourceCollector.pluginStyleables)
        extension.splitRJavaFile = splitRSourceFile

        extension.retainedAarLibs.each {
            def xmlManifest = new XmlParser().parse(it.manifest)
            String aarPackage = xmlManifest.@package
            def rJavaFile = new File(sourceOutputDir, "${aarPackage.replaceAll('\\.', File.separator)}${File.separator}R.java")
            aapt.generateRJava(rJavaFile, aarPackage, extension.aarResources, extension.aarStyleables)
        }
    }

    def convertResourcesForAapt(ListMultimap<String, ResourceEntry> pluginResources) {
        def retainedTypes = []
        retainedTypes.add(0,  [name: 'placeholder', id: Aapt.ID_NO_ATTR, entries: []])//attr 占位

        pluginResources.keySet().each { resType ->
            def firstEntry = pluginResources.get(resType).get(0)
            def typeEntry = [ type: "int", name: resType,
                              id: parseTypeIdFromResId(firstEntry.resourceId),
                              _id: parseTypeIdFromResId(firstEntry.newResourceId),
                              entries: []]

            pluginResources.get(resType).each { resEntry ->
                typeEntry.entries.add([
                        name : resEntry.resourceName,
                        id : parseEntryIdFromResId(resEntry.resourceId),
                        _id: parseEntryIdFromResId(resEntry.newResourceId),
                        v : resEntry.resourceId, _v : resEntry.newResourceId,
                        vs: resEntry.hexResourceId, _vs : resEntry.hexNewResourceId])
            }

            if (resType == 'attr') {
                retainedTypes.set(0, typeEntry)
            } else {
                retainedTypes.add(typeEntry)
            }
        }

        if (showLog) {
            println '===========convertResourcesForAapt '
            println retainedTypes
        }
        return retainedTypes
    }

    def convertStyleablesForAapt(List<StyleableEntry> pluginStyleables) {
        def retainedStyleables = []
        pluginStyleables.each { styleableEntry ->
            retainedStyleables.add([vtype : styleableEntry.valueType,
                                    type : 'styleable',
                                    key : styleableEntry.name,
                                    idStr : styleableEntry.value])
        }
        if (showLog) {
            println '===========convertStyleablesForAapt '
            println retainedStyleables
        }
        return retainedStyleables
    }

    /**
     * Parse the type part of a android resource id
     */
    def parseTypeIdFromResId(int resourceId) {
        resourceId >> 16 & 0xFF
    }

    /**
     * Parse the entry part of a android resource id
     */
    def parseEntryIdFromResId(int resourceId) {
        resourceId & 0xFFFF
    }
}